!***********************************************************************
!*                   GNU Lesser General Public License
!*
!* This file is part of the GFDL Flexible Modeling System (FMS) Coupler.
!*
!* FMS Coupler is free software: you can redistribute it and/or modify
!* it under the terms of the GNU Lesser General Public License as
!* published by the Free Software Foundation, either version 3 of the
!* License, or (at your option) any later version.
!*
!* FMS Coupler is distributed in the hope that it will be useful, but
!* WITHOUT ANY WARRANTY; without even the implied warranty of
!* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
!* General Public License for more details.
!*
!* You should have received a copy of the GNU Lesser General Public
!* License along with FMS Coupler.
!* If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
!> \file
!> \brief Handles flux exchanges and exchange grids between land and ice grids
module land_ice_flux_exchange_mod

!! FMS
  use FMS
  use FMSconstants, only: RADIUS
!! Components
  use land_model_mod,      only: land_data_type
  use ice_model_mod,       only: ice_data_type, land_ice_boundary_type

  implicit none
  private


  !---- exchange grid maps -----

  type(FmsXgridXmap_type), save :: xmap_runoff
  type(FmsXgridXmap_type), save :: xmap_IS
  integer         :: n_xgrid_runoff=0
  integer         :: n_xgrid_IS=0

  ! Exchange grid indices
  integer :: X2_GRID_LND, X2_GRID_ICE
  integer :: X2_IS_GRID_LND, X2_IS_GRID_ICE

  public :: flux_land_to_ice, land_ice_flux_exchange_init

  integer :: cplClock, fluxLandIceClock
  logical, save :: do_runoff, do_IS, do_calve, do_IS_mask
  real    :: Dt_cpl
contains

  subroutine land_ice_flux_exchange_init(Land, Ice, land_ice_boundary, Dt_cpl_in, do_runoff_in, cplClock_in, &
        calve_ice_shelf_bergs, ice_sheet_enabled)
    type(land_data_type),         intent(in)    :: Land !< A derived data type to specify land boundary data
    type(ice_data_type),          intent(inout) :: Ice !< A derived data type to specify ice boundary data
    type(land_ice_boundary_type), intent(inout) :: land_ice_boundary !< A derived data type to specify properties
                                                                     !! and fluxes passed from land to ice
    real,                         intent(in)    :: Dt_cpl_in
    logical,                      intent(in)    :: do_runoff_in
    integer,                      intent(in)    :: cplClock_in
    logical, optional,            intent(in)    :: calve_ice_shelf_bergs
    logical, optional,            intent(in)    :: ice_sheet_enabled
    real :: IS_mask_flag
    integer :: is, ie, js, je

    do_runoff = do_runoff_in
    cplClock = cplClock_in
    Dt_cpl   = Dt_cpl_in

    do_IS = .false.
    if (PRESENT(ice_sheet_enabled)) do_IS = ice_sheet_enabled

    do_calve = .false.
    if (PRESENT(calve_ice_shelf_bergs)) do_calve = calve_ice_shelf_bergs

    fluxLandIceClock = fms_mpp_clock_id( 'Flux land to ice', flags=fms_clock_flag_default, grain=CLOCK_ROUTINE )

    !if do_IS_mask is true, the ice-sheet mask is nonzero and will be exchanged from land to LIB
    !do_IS_mask will be false if using land_null, to avoid requiring the secondary xgrid directory INPUT_lndXIS
    do_IS_mask=.false. ; IS_mask_flag=0.0
    if (do_IS .or. do_calve) then
      if (any(Land%IS_mask_sg/=0.0)) IS_mask_flag=1.0
      call fms_mpp_max(IS_mask_flag)
      if (IS_mask_flag>0.0) do_IS_mask=.true.
    endif

    n_xgrid_IS=1
    if (do_IS.or.(do_calve.and.do_IS_mask)) then
       call fms_xgrid_setup_xmap(xmap_IS, (/ 'LND', 'OCN' /),       &
          (/ Land%Domain, Ice%Domain /),                    &
          "INPUT_lndXIS/grid_spec.nc", input_dir='INPUT_lndXIS/')
       ! exchange grid indices
       X2_IS_GRID_LND = 1; X2_IS_GRID_ICE = 2;
       n_xgrid_IS = max(fms_xgrid_count(xmap_IS),1)
       if (n_xgrid_IS.eq.1) write (*,'(a,i6,6x,a)') 'PE = ', fms_mpp_pe(), 'Ice sheet  exchange size equals one.'
       if (n_xgrid_IS>1) write (*,'(a,i6,6x,a,i6)') 'PE = ', fms_mpp_pe(), 'Ice sheet  exchange grid size= ',n_xgrid_IS
    endif

    if (do_runoff) then
       call fms_xgrid_setup_xmap(xmap_runoff, (/ 'LND', 'OCN' /),       &
            (/ Land%Domain, Ice%Domain /),                    &
            "INPUT/grid_spec.nc"             )
       ! exchange grid indices
       X2_GRID_LND = 1; X2_GRID_ICE = 2;
       n_xgrid_runoff = max(fms_xgrid_count(xmap_runoff),1)
       if (n_xgrid_runoff.eq.1) write (*,'(a,i6,6x,a)') 'PE = ', fms_mpp_pe(), 'Runoff  exchange size equals one.'
    endif

    call fms_mpp_domains_get_compute_domain( Ice%domain, is, ie, js, je )

    !allocate land_ice_boundary
    allocate( land_ice_boundary%runoff(is:ie,js:je) )
    allocate( land_ice_boundary%calving(is:ie,js:je) )
    allocate( land_ice_boundary%runoff_hflx(is:ie,js:je) )
    allocate( land_ice_boundary%calving_hflx(is:ie,js:je) )

    land_ice_boundary%do_calve = do_calve
    land_ice_boundary%do_IS = do_IS

    if (do_IS) then
      allocate( land_ice_boundary%IS_adot_sg(is:ie,js:je) )
      land_ice_boundary%IS_adot_sg=0.0
    endif

    if (do_IS .or. do_calve) then
       allocate( land_ice_boundary%IS_mask_sg(is:ie,js:je) )
       land_ice_boundary%IS_mask_sg=0.0
    endif

    ! initialize values for override experiments (mjh)
    land_ice_boundary%runoff=0.0
    land_ice_boundary%calving=0.0
    land_ice_boundary%runoff_hflx=0.0
    land_ice_boundary%calving_hflx=0.0


  end subroutine land_ice_flux_exchange_init

  !#######################################################################
  !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!
  ! flux_land_to_ice - translate runoff from land to ice grids                   !
  !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!
  !> \brief Conservative transfer of water and snow discharge from the land model to sea ice/ocean model.
  !!
  !! The following elements are transferred from the Land to the Land_ice_boundary:
  !! <pre>
  !!        IS_adot_sg (kg s-1) --> IS_adot_sg (kg m-2 s-1)
  !!        IS_mask_sg --> IS_mask_sg (nondim)
  !!        discharge --> runoff (kg/m2)
  !!        discharge_snow --> calving (kg/m2)
  !! </pre>
  subroutine flux_land_to_ice( Time, Land, Ice, Land_Ice_Boundary )
    type(FmsTime_type),                intent(in) :: Time !< Current time
    type(land_data_type),           intent(in) :: Land !< A derived data type to specify land boundary data
    type(ice_data_type),            intent(in) :: Ice !< A derived data type to specify ice boundary data
    !real, dimension(:,:),         intent(out) :: runoff_ice, calving_ice
    type(land_ice_boundary_type), intent(inout):: Land_Ice_Boundary !< A derived data type to specify properties
                                                                    !! and fluxes passed from land to ice

    integer                         :: ier
    real, dimension(n_xgrid_runoff) :: ex_runoff, ex_calving, ex_runoff_hflx, ex_calving_hflx
    real, dimension(n_xgrid_IS)     :: ex_adot, ex_adot_mask
    real, dimension(size(Land_Ice_Boundary%runoff,1),size(Land_Ice_Boundary%runoff,2),1) :: ice_buf

    !Balaji
    call fms_mpp_clock_begin(cplClock)
    call fms_mpp_clock_begin(fluxLandIceClock)

    ! ccc = conservation_check(Land%discharge, 'LND', xmap_runoff)
    ! if (fms_mpp_pe()==fms_mpp_root_pe()) print *,'RUNOFF', ccc

    if (do_IS.or.do_calve) then
       if (do_IS) then
          call fms_xgrid_put_to_xgrid ( Land%IS_adot_sg,      'LND', ex_adot,  xmap_IS) !Land%IS_adot_sg in (kg s-1)
          call fms_xgrid_get_from_xgrid (ice_buf, 'OCN', ex_adot,  xmap_IS)
          ! Land_Ice_Boundary%IS_adot_sg = ice_buf(:,:,1) / Ice%area
          call fms_data_override('ICE', 'IS_adot' , Land_Ice_Boundary%IS_adot_sg , Time) !override units: kg m-2 s-1
          ! Ice%IS_hole_adot_int = Land%IS_adot_int
       endif

       if (do_IS_mask) then
         call fms_xgrid_put_to_xgrid ( Land%IS_mask_sg,      'LND', ex_adot_mask,  xmap_IS)
         call fms_xgrid_get_from_xgrid (ice_buf, 'OCN', ex_adot_mask,  xmap_IS)
         Land_Ice_Boundary%IS_mask_sg = ice_buf(:,:,1)
         !TODO Land_Ice_boundaryIB%IS_mask_sg is currently unused, but could be a useful diagnostic
       endif
    endif

    if (do_runoff) then
       call fms_xgrid_put_to_xgrid ( Land%discharge,      'LND', ex_runoff,  xmap_runoff)
       call fms_xgrid_put_to_xgrid ( Land%discharge_snow, 'LND', ex_calving, xmap_runoff)
       call fms_xgrid_put_to_xgrid ( Land%discharge_heat,      'LND', ex_runoff_hflx,  xmap_runoff)
       call fms_xgrid_put_to_xgrid ( Land%discharge_snow_heat, 'LND', ex_calving_hflx, xmap_runoff)
       call fms_xgrid_get_from_xgrid (ice_buf, 'OCN', ex_runoff,  xmap_runoff)
       Land_Ice_Boundary%runoff = ice_buf(:,:,1);
       call fms_xgrid_get_from_xgrid (ice_buf, 'OCN', ex_calving, xmap_runoff)
       Land_Ice_Boundary%calving = ice_buf(:,:,1);
       call fms_xgrid_get_from_xgrid (ice_buf, 'OCN', ex_runoff_hflx,  xmap_runoff)
       Land_Ice_Boundary%runoff_hflx = ice_buf(:,:,1);
       call fms_xgrid_get_from_xgrid (ice_buf, 'OCN', ex_calving_hflx, xmap_runoff)
       Land_Ice_Boundary%calving_hflx = ice_buf(:,:,1);

       !Balaji
       call fms_data_override('ICE', 'runoff' , Land_Ice_Boundary%runoff , Time)
       call fms_data_override('ICE', 'calving', Land_Ice_Boundary%calving, Time)
       call fms_data_override('ICE', 'runoff_hflx' , Land_Ice_Boundary%runoff_hflx , Time)
       call fms_data_override('ICE', 'calving_hflx', Land_Ice_Boundary%calving_hflx, Time)

       ! compute stock increment
       ice_buf(:,:,1) = Land_Ice_Boundary%runoff + Land_Ice_Boundary%calving
       call fms_xgrid_stock_move(from=fms_stock_constants_lnd_stock(ISTOCK_WATER), &
            & to=fms_stock_constants_ice_stock(ISTOCK_WATER), &
            & grid_index=X2_GRID_ICE, &
            & stock_data3d=ice_buf, &
            & xmap=xmap_runoff, &
            & delta_t=Dt_cpl, &
            & from_side=ISTOCK_SIDE, to_side=ISTOCK_SIDE, &
            & radius=Radius, ier=ier, verbose='stock move RUNOFF+CALVING (Lnd->Ice) ')
    else
       Land_Ice_Boundary%runoff = 0.0
       Land_Ice_Boundary%calving = 0.0
       Land_Ice_Boundary%runoff_hflx = 0.0
       Land_Ice_Boundary%calving_hflx = 0.0
    endif

    call fms_mpp_clock_end(fluxLandIceClock)
    call fms_mpp_clock_end(cplClock)

  end subroutine flux_land_to_ice


!#######################################################################

end module land_ice_flux_exchange_mod
